// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/registry/registry.proto
// DO NOT EDIT!

/*
Package registry is a generated protocol buffer package.


do not change the package name
rpc clients refer to the service by package name,
so if you change this, you need to change ALL clients
at the same time

It is generated from these files:
	protos/golang.conradwood.net/apis/registry/registry.proto

It has these top-level messages:
	RoutingInfo
	ServiceDescription
	ServiceAddress
	ServiceLocation
	GetRequest
	GetResponse
	ShutdownRequest
	ListResponse
	EmptyResponse
	ListRequest
	DeregisterRequest
	GetUpstreamTargetRequest
	GetTargetRequest
	ProcessShutdownRequest
	HideUpdateRequest
	HideServiceRequest
	ByIPPortRequest
	ByIPPortResponse
	CreateServiceRequest
	RegisterServiceRequest
	RegisterServiceResponse
	HeartBeatRequest
	DeregisterServiceRequest
	Target
	V2GetTargetRequest
	V2GetTargetResponse
	Registration
	RegistrationList
	V2ListRequest
	DownstreamTargetResponse
	UpstreamTargetRequest
	MissedLookup
	MissedLookupList
*/
package registry

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import auth "golang.conradwood.net/apis/auth"
import autodeployer "golang.conradwood.net/apis/autodeployer"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Apitype int32

const (
	Apitype_status Apitype = 0
	Apitype_grpc   Apitype = 1
	Apitype_json   Apitype = 2
	Apitype_html   Apitype = 3
	Apitype_tcp    Apitype = 4
)

var Apitype_name = map[int32]string{
	0: "status",
	1: "grpc",
	2: "json",
	3: "html",
	4: "tcp",
}
var Apitype_value = map[string]int32{
	"status": 0,
	"grpc":   1,
	"json":   2,
	"html":   3,
	"tcp":    4,
}

func (x Apitype) String() string {
	return proto.EnumName(Apitype_name, int32(x))
}
func (Apitype) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// some instances have a "special" routing, for example, for certain users only during tests
// or experiments or so. RoutingInfo defines attributes that can be used by the client loadbalancers
// to pick a route. It also identifies routes for multiplexers or proxies loadbalancers' to route to remote endpoints.
// The RoutingInfo is passed for each call in the context metadata
type RoutingInfo struct {
	// A service might be running under a useraccount instead of a serviceaccount
	RunningAs *auth.User `protobuf:"bytes,1,opt,name=RunningAs" json:"RunningAs,omitempty"`
	// We might have multiplexer/proxies, which annoyingly require more than IP:PORT.
	// This field identifies the (from our perspective) remote node
	// for example it identifies which dev-server to send it to
	GatewayID string `protobuf:"bytes,2,opt,name=GatewayID" json:"GatewayID,omitempty"`
	// the remote node might expose multiple services, this identifies the Endpoint
	// (thus it is unique and meaningful on the remote end only)
	// for example, the dev-server might store something here which is useful for it only
	EndpointID string `protobuf:"bytes,3,opt,name=EndpointID" json:"EndpointID,omitempty"`
	// special tags for this target. Tags are another "routinginfo". A client may request a service with certain tags. If so, any rpc will be routed to a service where all tags match exactly. this happens AFTER user-matching has been performed. That means, the order is: 1. filter for user and 2. filter for tags. If user service has no matching routing tags (but a user service IS running) the call will be rejected with "No Target". This helps in routing within clusters or other special cases
	Tags map[string]string `protobuf:"bytes,4,rep,name=Tags" json:"Tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RoutingInfo) Reset()                    { *m = RoutingInfo{} }
func (m *RoutingInfo) String() string            { return proto.CompactTextString(m) }
func (*RoutingInfo) ProtoMessage()               {}
func (*RoutingInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *RoutingInfo) GetRunningAs() *auth.User {
	if m != nil {
		return m.RunningAs
	}
	return nil
}

func (m *RoutingInfo) GetGatewayID() string {
	if m != nil {
		return m.GatewayID
	}
	return ""
}

func (m *RoutingInfo) GetEndpointID() string {
	if m != nil {
		return m.EndpointID
	}
	return ""
}

func (m *RoutingInfo) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

type ServiceDescription struct {
	Name string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Path string `protobuf:"bytes,2,opt,name=Path" json:"Path,omitempty"`
}

func (m *ServiceDescription) Reset()                    { *m = ServiceDescription{} }
func (m *ServiceDescription) String() string            { return proto.CompactTextString(m) }
func (*ServiceDescription) ProtoMessage()               {}
func (*ServiceDescription) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ServiceDescription) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ServiceDescription) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// on a given port, we can have multiple apis
type ServiceAddress struct {
	Host    string    `protobuf:"bytes,1,opt,name=Host" json:"Host,omitempty"`
	Port    int32     `protobuf:"varint,2,opt,name=Port" json:"Port,omitempty"`
	ApiType []Apitype `protobuf:"varint,3,rep,packed,name=ApiType,enum=registry.Apitype" json:"ApiType,omitempty"`
	// true if this address is filtered
	// also see "ShowFiltered" in ListRequest Message
	Filtered    bool         `protobuf:"varint,4,opt,name=Filtered" json:"Filtered,omitempty"`
	RoutingInfo *RoutingInfo `protobuf:"bytes,5,opt,name=RoutingInfo" json:"RoutingInfo,omitempty"`
}

func (m *ServiceAddress) Reset()                    { *m = ServiceAddress{} }
func (m *ServiceAddress) String() string            { return proto.CompactTextString(m) }
func (*ServiceAddress) ProtoMessage()               {}
func (*ServiceAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ServiceAddress) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ServiceAddress) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *ServiceAddress) GetApiType() []Apitype {
	if m != nil {
		return m.ApiType
	}
	return nil
}

func (m *ServiceAddress) GetFiltered() bool {
	if m != nil {
		return m.Filtered
	}
	return false
}

func (m *ServiceAddress) GetRoutingInfo() *RoutingInfo {
	if m != nil {
		return m.RoutingInfo
	}
	return nil
}

type ServiceLocation struct {
	Service *ServiceDescription `protobuf:"bytes,1,opt,name=Service" json:"Service,omitempty"`
	Address []*ServiceAddress   `protobuf:"bytes,2,rep,name=Address" json:"Address,omitempty"`
}

func (m *ServiceLocation) Reset()                    { *m = ServiceLocation{} }
func (m *ServiceLocation) String() string            { return proto.CompactTextString(m) }
func (*ServiceLocation) ProtoMessage()               {}
func (*ServiceLocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ServiceLocation) GetService() *ServiceDescription {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *ServiceLocation) GetAddress() []*ServiceAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

type GetRequest struct {
	Service *ServiceDescription `protobuf:"bytes,1,opt,name=Service" json:"Service,omitempty"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *GetRequest) GetService() *ServiceDescription {
	if m != nil {
		return m.Service
	}
	return nil
}

type GetResponse struct {
	Service   *ServiceDescription `protobuf:"bytes,1,opt,name=Service" json:"Service,omitempty"`
	Location  *ServiceLocation    `protobuf:"bytes,2,opt,name=Location" json:"Location,omitempty"`
	ServiceID string              `protobuf:"bytes,3,opt,name=ServiceID" json:"ServiceID,omitempty"`
	YourIP    string              `protobuf:"bytes,4,opt,name=YourIP" json:"YourIP,omitempty"`
}

func (m *GetResponse) Reset()                    { *m = GetResponse{} }
func (m *GetResponse) String() string            { return proto.CompactTextString(m) }
func (*GetResponse) ProtoMessage()               {}
func (*GetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetResponse) GetService() *ServiceDescription {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *GetResponse) GetLocation() *ServiceLocation {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *GetResponse) GetServiceID() string {
	if m != nil {
		return m.ServiceID
	}
	return ""
}

func (m *GetResponse) GetYourIP() string {
	if m != nil {
		return m.YourIP
	}
	return ""
}

type ShutdownRequest struct {
	ServiceName string `protobuf:"bytes,1,opt,name=ServiceName" json:"ServiceName,omitempty"`
}

func (m *ShutdownRequest) Reset()                    { *m = ShutdownRequest{} }
func (m *ShutdownRequest) String() string            { return proto.CompactTextString(m) }
func (*ShutdownRequest) ProtoMessage()               {}
func (*ShutdownRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *ShutdownRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

type ListResponse struct {
	Service []*GetResponse `protobuf:"bytes,3,rep,name=Service" json:"Service,omitempty"`
}

func (m *ListResponse) Reset()                    { *m = ListResponse{} }
func (m *ListResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()               {}
func (*ListResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ListResponse) GetService() []*GetResponse {
	if m != nil {
		return m.Service
	}
	return nil
}

type EmptyResponse struct {
}

func (m *EmptyResponse) Reset()                    { *m = EmptyResponse{} }
func (m *EmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmptyResponse) ProtoMessage()               {}
func (*EmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type ListRequest struct {
	// optional - if set filter by Name
	Name         string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	ShowFiltered bool   `protobuf:"varint,2,opt,name=ShowFiltered" json:"ShowFiltered,omitempty"`
	// optional - fuzzy filter by multiple names
	// this is meant to be helpful for Command line applications
	// idiomatic way: LookupRequest{NameMatches: flag.Args()}
	NameMatches []string `protobuf:"bytes,3,rep,name=NameMatches" json:"NameMatches,omitempty"`
}

func (m *ListRequest) Reset()                    { *m = ListRequest{} }
func (m *ListRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()               {}
func (*ListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ListRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ListRequest) GetShowFiltered() bool {
	if m != nil {
		return m.ShowFiltered
	}
	return false
}

func (m *ListRequest) GetNameMatches() []string {
	if m != nil {
		return m.NameMatches
	}
	return nil
}

type DeregisterRequest struct {
	ServiceID string `protobuf:"bytes,1,opt,name=ServiceID" json:"ServiceID,omitempty"`
}

func (m *DeregisterRequest) Reset()                    { *m = DeregisterRequest{} }
func (m *DeregisterRequest) String() string            { return proto.CompactTextString(m) }
func (*DeregisterRequest) ProtoMessage()               {}
func (*DeregisterRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *DeregisterRequest) GetServiceID() string {
	if m != nil {
		return m.ServiceID
	}
	return ""
}

type GetUpstreamTargetRequest struct {
	TargetRequest *GetTargetRequest `protobuf:"bytes,2,opt,name=TargetRequest" json:"TargetRequest,omitempty"`
	Callers       []uint64          `protobuf:"varint,3,rep,packed,name=Callers" json:"Callers,omitempty"`
}

func (m *GetUpstreamTargetRequest) Reset()                    { *m = GetUpstreamTargetRequest{} }
func (m *GetUpstreamTargetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetUpstreamTargetRequest) ProtoMessage()               {}
func (*GetUpstreamTargetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *GetUpstreamTargetRequest) GetTargetRequest() *GetTargetRequest {
	if m != nil {
		return m.TargetRequest
	}
	return nil
}

func (m *GetUpstreamTargetRequest) GetCallers() []uint64 {
	if m != nil {
		return m.Callers
	}
	return nil
}

type GetTargetRequest struct {
	// use either Path or name - not both
	Path    string  `protobuf:"bytes,1,opt,name=Path" json:"Path,omitempty"`
	Name    string  `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	ApiType Apitype `protobuf:"varint,3,opt,name=ApiType,enum=registry.Apitype" json:"ApiType,omitempty"`
}

func (m *GetTargetRequest) Reset()                    { *m = GetTargetRequest{} }
func (m *GetTargetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTargetRequest) ProtoMessage()               {}
func (*GetTargetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GetTargetRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *GetTargetRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetTargetRequest) GetApiType() Apitype {
	if m != nil {
		return m.ApiType
	}
	return Apitype_status
}

type ProcessShutdownRequest struct {
	// optional, if nil use originators ip
	IP string `protobuf:"bytes,1,opt,name=IP" json:"IP,omitempty"`
	// list all the ports we just shutdown...
	Port []int32 `protobuf:"varint,2,rep,packed,name=Port" json:"Port,omitempty"`
}

func (m *ProcessShutdownRequest) Reset()                    { *m = ProcessShutdownRequest{} }
func (m *ProcessShutdownRequest) String() string            { return proto.CompactTextString(m) }
func (*ProcessShutdownRequest) ProtoMessage()               {}
func (*ProcessShutdownRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ProcessShutdownRequest) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *ProcessShutdownRequest) GetPort() []int32 {
	if m != nil {
		return m.Port
	}
	return nil
}

type HideUpdateRequest struct {
	IP     string `protobuf:"bytes,1,opt,name=IP" json:"IP,omitempty"`
	Enable bool   `protobuf:"varint,2,opt,name=Enable" json:"Enable,omitempty"`
}

func (m *HideUpdateRequest) Reset()                    { *m = HideUpdateRequest{} }
func (m *HideUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*HideUpdateRequest) ProtoMessage()               {}
func (*HideUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *HideUpdateRequest) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *HideUpdateRequest) GetEnable() bool {
	if m != nil {
		return m.Enable
	}
	return false
}

type HideServiceRequest struct {
	Address *ServiceAddress `protobuf:"bytes,1,opt,name=Address" json:"Address,omitempty"`
	// setting this to 0 will effectively remove the hiding again
	TimeoutSeconds int32 `protobuf:"varint,2,opt,name=TimeoutSeconds" json:"TimeoutSeconds,omitempty"`
}

func (m *HideServiceRequest) Reset()                    { *m = HideServiceRequest{} }
func (m *HideServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*HideServiceRequest) ProtoMessage()               {}
func (*HideServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *HideServiceRequest) GetAddress() *ServiceAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *HideServiceRequest) GetTimeoutSeconds() int32 {
	if m != nil {
		return m.TimeoutSeconds
	}
	return 0
}

type ByIPPortRequest struct {
	Address      string `protobuf:"bytes,1,opt,name=Address" json:"Address,omitempty"`
	Port         uint32 `protobuf:"varint,2,opt,name=Port" json:"Port,omitempty"`
	ShowFiltered bool   `protobuf:"varint,3,opt,name=ShowFiltered" json:"ShowFiltered,omitempty"`
}

func (m *ByIPPortRequest) Reset()                    { *m = ByIPPortRequest{} }
func (m *ByIPPortRequest) String() string            { return proto.CompactTextString(m) }
func (*ByIPPortRequest) ProtoMessage()               {}
func (*ByIPPortRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ByIPPortRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ByIPPortRequest) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *ByIPPortRequest) GetShowFiltered() bool {
	if m != nil {
		return m.ShowFiltered
	}
	return false
}

type ByIPPortResponse struct {
	Service  *ServiceDescription `protobuf:"bytes,1,opt,name=Service" json:"Service,omitempty"`
	ApiType  []Apitype           `protobuf:"varint,2,rep,packed,name=ApiType,enum=registry.Apitype" json:"ApiType,omitempty"`
	Filtered bool                `protobuf:"varint,3,opt,name=Filtered" json:"Filtered,omitempty"`
}

func (m *ByIPPortResponse) Reset()                    { *m = ByIPPortResponse{} }
func (m *ByIPPortResponse) String() string            { return proto.CompactTextString(m) }
func (*ByIPPortResponse) ProtoMessage()               {}
func (*ByIPPortResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ByIPPortResponse) GetService() *ServiceDescription {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *ByIPPortResponse) GetApiType() []Apitype {
	if m != nil {
		return m.ApiType
	}
	return nil
}

func (m *ByIPPortResponse) GetFiltered() bool {
	if m != nil {
		return m.Filtered
	}
	return false
}

// new style create service
// it contains more information and also _should_ be easier to use for clients (more intuitive)
// this is intented to be sent prior to a registrationrequest from a trusted source (e.g. autodeployer)
type CreateServiceRequest struct {
	// all registrations of a process must share the same processid (startupid ass assigned by autodeployer)
	// this way if it exists we clean up all registrations of same process on that host
	ProcessID string `protobuf:"bytes,1,opt,name=ProcessID" json:"ProcessID,omitempty"`
	// this is mandatory in the datacenter, but optional on "test" clients
	DeployInfo *autodeployer.DeployInfo `protobuf:"bytes,2,opt,name=DeployInfo" json:"DeployInfo,omitempty"`
	// experimental idea - different partitions to isolate services from each other?
	// e.g. for different organisations or different users?
	// maybe a "Domain"? (but that is soooo WindowsNT)
	Partition string `protobuf:"bytes,3,opt,name=Partition" json:"Partition,omitempty"`
	// pid of the process.
	Pid uint64 `protobuf:"varint,4,opt,name=Pid" json:"Pid,omitempty"`
}

func (m *CreateServiceRequest) Reset()                    { *m = CreateServiceRequest{} }
func (m *CreateServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateServiceRequest) ProtoMessage()               {}
func (*CreateServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *CreateServiceRequest) GetProcessID() string {
	if m != nil {
		return m.ProcessID
	}
	return ""
}

func (m *CreateServiceRequest) GetDeployInfo() *autodeployer.DeployInfo {
	if m != nil {
		return m.DeployInfo
	}
	return nil
}

func (m *CreateServiceRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *CreateServiceRequest) GetPid() uint64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

// new style create service
// it contains more information and also _should_ be easier to use for clients (more intuitive)
type RegisterServiceRequest struct {
	// all registrations of a process must share the same processid (startupid ass assigned by autodeployer)
	// this way if it exists we clean up all registrations of same process on that host
	// on "test" clients, this is usally locally generated, but every registration of the same process must have
	// the same ProcessID (e.g. an ge_instance_id)
	ProcessID string `protobuf:"bytes,1,opt,name=ProcessID" json:"ProcessID,omitempty"`
	// the port we are registering
	Port uint32 `protobuf:"varint,2,opt,name=Port" json:"Port,omitempty"`
	// the apitypes available on this port
	ApiType []Apitype `protobuf:"varint,3,rep,packed,name=ApiType,enum=registry.Apitype" json:"ApiType,omitempty"`
	// the service name, e.g. "helloworld.HelloWorld"
	ServiceName string `protobuf:"bytes,4,opt,name=ServiceName" json:"ServiceName,omitempty"`
	// optional routinginfo
	// the registry largely ignores this. the client loadbalancer needs this though
	RoutingInfo *RoutingInfo `protobuf:"bytes,5,opt,name=RoutingInfo" json:"RoutingInfo,omitempty"`
	Pid         uint64       `protobuf:"varint,6,opt,name=Pid" json:"Pid,omitempty"`
}

func (m *RegisterServiceRequest) Reset()                    { *m = RegisterServiceRequest{} }
func (m *RegisterServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterServiceRequest) ProtoMessage()               {}
func (*RegisterServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *RegisterServiceRequest) GetProcessID() string {
	if m != nil {
		return m.ProcessID
	}
	return ""
}

func (m *RegisterServiceRequest) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *RegisterServiceRequest) GetApiType() []Apitype {
	if m != nil {
		return m.ApiType
	}
	return nil
}

func (m *RegisterServiceRequest) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *RegisterServiceRequest) GetRoutingInfo() *RoutingInfo {
	if m != nil {
		return m.RoutingInfo
	}
	return nil
}

func (m *RegisterServiceRequest) GetPid() uint64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

// nothing here really.
type RegisterServiceResponse struct {
}

func (m *RegisterServiceResponse) Reset()                    { *m = RegisterServiceResponse{} }
func (m *RegisterServiceResponse) String() string            { return proto.CompactTextString(m) }
func (*RegisterServiceResponse) ProtoMessage()               {}
func (*RegisterServiceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

// the process is still alive..
type HeartBeatRequest struct {
	// all registrations of a process must share the same processid (startupid ass assigned by autodeployer)
	// this way if it exists we clean up all registrations of same process on that host
	// the client is supposed to call this regularly
	ProcessID string `protobuf:"bytes,1,opt,name=ProcessID" json:"ProcessID,omitempty"`
}

func (m *HeartBeatRequest) Reset()                    { *m = HeartBeatRequest{} }
func (m *HeartBeatRequest) String() string            { return proto.CompactTextString(m) }
func (*HeartBeatRequest) ProtoMessage()               {}
func (*HeartBeatRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *HeartBeatRequest) GetProcessID() string {
	if m != nil {
		return m.ProcessID
	}
	return ""
}

type DeregisterServiceRequest struct {
	// all registrations of a process must share the same processid (startupid ass assigned by autodeployer)
	// this way if it exists we clean up all registrations of same process on that host
	ProcessID string `protobuf:"bytes,1,opt,name=ProcessID" json:"ProcessID,omitempty"`
}

func (m *DeregisterServiceRequest) Reset()                    { *m = DeregisterServiceRequest{} }
func (m *DeregisterServiceRequest) String() string            { return proto.CompactTextString(m) }
func (*DeregisterServiceRequest) ProtoMessage()               {}
func (*DeregisterServiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *DeregisterServiceRequest) GetProcessID() string {
	if m != nil {
		return m.ProcessID
	}
	return ""
}

type Target struct {
	ServiceName string `protobuf:"bytes,1,opt,name=ServiceName" json:"ServiceName,omitempty"`
	IP          string `protobuf:"bytes,2,opt,name=IP" json:"IP,omitempty"`
	Port        uint32 `protobuf:"varint,3,opt,name=Port" json:"Port,omitempty"`
	// all supported apitypes on this target
	ApiType     []Apitype    `protobuf:"varint,4,rep,packed,name=ApiType,enum=registry.Apitype" json:"ApiType,omitempty"`
	RoutingInfo *RoutingInfo `protobuf:"bytes,5,opt,name=RoutingInfo" json:"RoutingInfo,omitempty"`
	// the partition this service is in
	Partition string `protobuf:"bytes,6,opt,name=Partition" json:"Partition,omitempty"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Target) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *Target) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *Target) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Target) GetApiType() []Apitype {
	if m != nil {
		return m.ApiType
	}
	return nil
}

func (m *Target) GetRoutingInfo() *RoutingInfo {
	if m != nil {
		return m.RoutingInfo
	}
	return nil
}

func (m *Target) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

type V2GetTargetRequest struct {
	// which apitype are we after?
	ApiType Apitype `protobuf:"varint,1,opt,name=ApiType,enum=registry.Apitype" json:"ApiType,omitempty"`
	//
	// which services are we after?
	// Note that one cannot query for multiple apitypes in one go. use multiple calls to do so
	ServiceName []string `protobuf:"bytes,2,rep,name=ServiceName" json:"ServiceName,omitempty"`
	//
	// going with the experimental "Partition" Idea in create service we can query for different partitions.
	// limited by some user account lookup/match
	Partition string `protobuf:"bytes,3,opt,name=Partition" json:"Partition,omitempty"`
	//
	// if true it will ignore the partition on match and return services from all partitions
	// (privileged)
	AllPartitions bool `protobuf:"varint,4,opt,name=AllPartitions" json:"AllPartitions,omitempty"`
}

func (m *V2GetTargetRequest) Reset()                    { *m = V2GetTargetRequest{} }
func (m *V2GetTargetRequest) String() string            { return proto.CompactTextString(m) }
func (*V2GetTargetRequest) ProtoMessage()               {}
func (*V2GetTargetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *V2GetTargetRequest) GetApiType() Apitype {
	if m != nil {
		return m.ApiType
	}
	return Apitype_status
}

func (m *V2GetTargetRequest) GetServiceName() []string {
	if m != nil {
		return m.ServiceName
	}
	return nil
}

func (m *V2GetTargetRequest) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *V2GetTargetRequest) GetAllPartitions() bool {
	if m != nil {
		return m.AllPartitions
	}
	return false
}

type V2GetTargetResponse struct {
	Targets []*Target `protobuf:"bytes,1,rep,name=Targets" json:"Targets,omitempty"`
}

func (m *V2GetTargetResponse) Reset()                    { *m = V2GetTargetResponse{} }
func (m *V2GetTargetResponse) String() string            { return proto.CompactTextString(m) }
func (*V2GetTargetResponse) ProtoMessage()               {}
func (*V2GetTargetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *V2GetTargetResponse) GetTargets() []*Target {
	if m != nil {
		return m.Targets
	}
	return nil
}

// a more complete view than just Target. useful for listing
type Registration struct {
	Target *Target `protobuf:"bytes,1,opt,name=Target" json:"Target,omitempty"`
	// is this served as a target at the moment?
	Targetable bool                     `protobuf:"varint,2,opt,name=Targetable" json:"Targetable,omitempty"`
	ProcessID  string                   `protobuf:"bytes,3,opt,name=ProcessID" json:"ProcessID,omitempty"`
	DeployInfo *autodeployer.DeployInfo `protobuf:"bytes,4,opt,name=DeployInfo" json:"DeployInfo,omitempty"`
	Pid        uint64                   `protobuf:"varint,5,opt,name=Pid" json:"Pid,omitempty"`
	// unix epoch when the service last sent a heartbeat or registration
	LastRefreshed uint32 `protobuf:"varint,6,opt,name=LastRefreshed" json:"LastRefreshed,omitempty"`
	// if it is in a partition, then this will be set
	Partition string `protobuf:"bytes,7,opt,name=Partition" json:"Partition,omitempty"`
	// deregistered services might still show up for a short while but then they are no longer 'running'
	Running bool `protobuf:"varint,8,opt,name=Running" json:"Running,omitempty"`
}

func (m *Registration) Reset()                    { *m = Registration{} }
func (m *Registration) String() string            { return proto.CompactTextString(m) }
func (*Registration) ProtoMessage()               {}
func (*Registration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *Registration) GetTarget() *Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Registration) GetTargetable() bool {
	if m != nil {
		return m.Targetable
	}
	return false
}

func (m *Registration) GetProcessID() string {
	if m != nil {
		return m.ProcessID
	}
	return ""
}

func (m *Registration) GetDeployInfo() *autodeployer.DeployInfo {
	if m != nil {
		return m.DeployInfo
	}
	return nil
}

func (m *Registration) GetPid() uint64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *Registration) GetLastRefreshed() uint32 {
	if m != nil {
		return m.LastRefreshed
	}
	return 0
}

func (m *Registration) GetPartition() string {
	if m != nil {
		return m.Partition
	}
	return ""
}

func (m *Registration) GetRunning() bool {
	if m != nil {
		return m.Running
	}
	return false
}

type RegistrationList struct {
	Registrations []*Registration `protobuf:"bytes,1,rep,name=Registrations" json:"Registrations,omitempty"`
}

func (m *RegistrationList) Reset()                    { *m = RegistrationList{} }
func (m *RegistrationList) String() string            { return proto.CompactTextString(m) }
func (*RegistrationList) ProtoMessage()               {}
func (*RegistrationList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *RegistrationList) GetRegistrations() []*Registration {
	if m != nil {
		return m.Registrations
	}
	return nil
}

type V2ListRequest struct {
	NameMatch string `protobuf:"bytes,1,opt,name=NameMatch" json:"NameMatch,omitempty"`
}

func (m *V2ListRequest) Reset()                    { *m = V2ListRequest{} }
func (m *V2ListRequest) String() string            { return proto.CompactTextString(m) }
func (*V2ListRequest) ProtoMessage()               {}
func (*V2ListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *V2ListRequest) GetNameMatch() string {
	if m != nil {
		return m.NameMatch
	}
	return ""
}

type DownstreamTargetResponse struct {
	Response *V2GetTargetResponse `protobuf:"bytes,1,opt,name=Response" json:"Response,omitempty"`
	// each registry adds all registry ids to the response
	RegistryIDs []string `protobuf:"bytes,2,rep,name=RegistryIDs" json:"RegistryIDs,omitempty"`
}

func (m *DownstreamTargetResponse) Reset()                    { *m = DownstreamTargetResponse{} }
func (m *DownstreamTargetResponse) String() string            { return proto.CompactTextString(m) }
func (*DownstreamTargetResponse) ProtoMessage()               {}
func (*DownstreamTargetResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *DownstreamTargetResponse) GetResponse() *V2GetTargetResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *DownstreamTargetResponse) GetRegistryIDs() []string {
	if m != nil {
		return m.RegistryIDs
	}
	return nil
}

type UpstreamTargetRequest struct {
	Request *V2GetTargetRequest `protobuf:"bytes,1,opt,name=Request" json:"Request,omitempty"`
	// each registry adds its ID to this list
	// to avoid loops, if a registry finds itself in here it does not contact any upstreams
	// and returns an empty list instead
	RegistryIDs []string `protobuf:"bytes,2,rep,name=RegistryIDs" json:"RegistryIDs,omitempty"`
	// each registry decrements by one. if 0, registry won't ask upstream
	TTL uint32 `protobuf:"varint,3,opt,name=TTL" json:"TTL,omitempty"`
}

func (m *UpstreamTargetRequest) Reset()                    { *m = UpstreamTargetRequest{} }
func (m *UpstreamTargetRequest) String() string            { return proto.CompactTextString(m) }
func (*UpstreamTargetRequest) ProtoMessage()               {}
func (*UpstreamTargetRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *UpstreamTargetRequest) GetRequest() *V2GetTargetRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *UpstreamTargetRequest) GetRegistryIDs() []string {
	if m != nil {
		return m.RegistryIDs
	}
	return nil
}

func (m *UpstreamTargetRequest) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

type MissedLookup struct {
	ServiceName string `protobuf:"bytes,1,opt,name=ServiceName" json:"ServiceName,omitempty"`
	Last        uint32 `protobuf:"varint,2,opt,name=Last" json:"Last,omitempty"`
	Missed      uint32 `protobuf:"varint,3,opt,name=Missed" json:"Missed,omitempty"`
	Found       uint32 `protobuf:"varint,4,opt,name=Found" json:"Found,omitempty"`
}

func (m *MissedLookup) Reset()                    { *m = MissedLookup{} }
func (m *MissedLookup) String() string            { return proto.CompactTextString(m) }
func (*MissedLookup) ProtoMessage()               {}
func (*MissedLookup) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *MissedLookup) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

func (m *MissedLookup) GetLast() uint32 {
	if m != nil {
		return m.Last
	}
	return 0
}

func (m *MissedLookup) GetMissed() uint32 {
	if m != nil {
		return m.Missed
	}
	return 0
}

func (m *MissedLookup) GetFound() uint32 {
	if m != nil {
		return m.Found
	}
	return 0
}

type MissedLookupList struct {
	Lookups []*MissedLookup `protobuf:"bytes,1,rep,name=Lookups" json:"Lookups,omitempty"`
}

func (m *MissedLookupList) Reset()                    { *m = MissedLookupList{} }
func (m *MissedLookupList) String() string            { return proto.CompactTextString(m) }
func (*MissedLookupList) ProtoMessage()               {}
func (*MissedLookupList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *MissedLookupList) GetLookups() []*MissedLookup {
	if m != nil {
		return m.Lookups
	}
	return nil
}

func init() {
	proto.RegisterType((*RoutingInfo)(nil), "registry.RoutingInfo")
	proto.RegisterType((*ServiceDescription)(nil), "registry.ServiceDescription")
	proto.RegisterType((*ServiceAddress)(nil), "registry.ServiceAddress")
	proto.RegisterType((*ServiceLocation)(nil), "registry.ServiceLocation")
	proto.RegisterType((*GetRequest)(nil), "registry.GetRequest")
	proto.RegisterType((*GetResponse)(nil), "registry.GetResponse")
	proto.RegisterType((*ShutdownRequest)(nil), "registry.ShutdownRequest")
	proto.RegisterType((*ListResponse)(nil), "registry.ListResponse")
	proto.RegisterType((*EmptyResponse)(nil), "registry.EmptyResponse")
	proto.RegisterType((*ListRequest)(nil), "registry.ListRequest")
	proto.RegisterType((*DeregisterRequest)(nil), "registry.DeregisterRequest")
	proto.RegisterType((*GetUpstreamTargetRequest)(nil), "registry.GetUpstreamTargetRequest")
	proto.RegisterType((*GetTargetRequest)(nil), "registry.GetTargetRequest")
	proto.RegisterType((*ProcessShutdownRequest)(nil), "registry.ProcessShutdownRequest")
	proto.RegisterType((*HideUpdateRequest)(nil), "registry.HideUpdateRequest")
	proto.RegisterType((*HideServiceRequest)(nil), "registry.HideServiceRequest")
	proto.RegisterType((*ByIPPortRequest)(nil), "registry.ByIPPortRequest")
	proto.RegisterType((*ByIPPortResponse)(nil), "registry.ByIPPortResponse")
	proto.RegisterType((*CreateServiceRequest)(nil), "registry.CreateServiceRequest")
	proto.RegisterType((*RegisterServiceRequest)(nil), "registry.RegisterServiceRequest")
	proto.RegisterType((*RegisterServiceResponse)(nil), "registry.RegisterServiceResponse")
	proto.RegisterType((*HeartBeatRequest)(nil), "registry.HeartBeatRequest")
	proto.RegisterType((*DeregisterServiceRequest)(nil), "registry.DeregisterServiceRequest")
	proto.RegisterType((*Target)(nil), "registry.Target")
	proto.RegisterType((*V2GetTargetRequest)(nil), "registry.V2GetTargetRequest")
	proto.RegisterType((*V2GetTargetResponse)(nil), "registry.V2GetTargetResponse")
	proto.RegisterType((*Registration)(nil), "registry.Registration")
	proto.RegisterType((*RegistrationList)(nil), "registry.RegistrationList")
	proto.RegisterType((*V2ListRequest)(nil), "registry.V2ListRequest")
	proto.RegisterType((*DownstreamTargetResponse)(nil), "registry.DownstreamTargetResponse")
	proto.RegisterType((*UpstreamTargetRequest)(nil), "registry.UpstreamTargetRequest")
	proto.RegisterType((*MissedLookup)(nil), "registry.MissedLookup")
	proto.RegisterType((*MissedLookupList)(nil), "registry.MissedLookupList")
	proto.RegisterEnum("registry.Apitype", Apitype_name, Apitype_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Registry service

type RegistryClient interface {
	// DEPRECATED get all instances of a service
	GetTarget(ctx context.Context, in *GetTargetRequest, opts ...grpc.CallOption) (*ListResponse, error)
	// this is called, by the autodeployer if it detects a shutdown process
	// essentially the ports and ip will be deregistered
	InformProcessShutdown(ctx context.Context, in *ProcessShutdownRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// autodeployer will a service before handing over control to userspace (using processid)
	V2CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*common.Void, error)
	// new style registration
	V2RegisterService(ctx context.Context, in *RegisterServiceRequest, opts ...grpc.CallOption) (*RegisterServiceResponse, error)
	// new style 'refresh' (keep-alive)
	V2HeartBeat(ctx context.Context, in *HeartBeatRequest, opts ...grpc.CallOption) (*common.Void, error)
	// new style 'deregister' service. This is based on processID. all services/ports for
	// the given processid will be deregistered.
	V2DeregisterService(ctx context.Context, in *DeregisterServiceRequest, opts ...grpc.CallOption) (*common.Void, error)
	// new style queries. this will give us specific services, e.g. only the latest instance
	// or "the right instance" - whatever that might turn out to be. It won't for example
	// give instances that are scheduled for shutdown or so.
	V2GetTarget(ctx context.Context, in *V2GetTargetRequest, opts ...grpc.CallOption) (*V2GetTargetResponse, error)
	// admin stuff to look at what is registered and to create graphs and whatnot for it
	// this gives all registrations
	ListRegistrations(ctx context.Context, in *V2ListRequest, opts ...grpc.CallOption) (*RegistrationList, error)
	// registry-to-registry target resolutions.
	// a registry calls this rpc on a remote registry with the request to resolve a target
	RequestForTarget(ctx context.Context, in *UpstreamTargetRequest, opts ...grpc.CallOption) (*DownstreamTargetResponse, error)
	// get me list of missed (local) target (those pulled from upstream)
	GetMissedLookups(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*MissedLookupList, error)
}

type registryClient struct {
	cc *grpc.ClientConn
}

func NewRegistryClient(cc *grpc.ClientConn) RegistryClient {
	return &registryClient{cc}
}

func (c *registryClient) GetTarget(ctx context.Context, in *GetTargetRequest, opts ...grpc.CallOption) (*ListResponse, error) {
	out := new(ListResponse)
	err := grpc.Invoke(ctx, "/registry.Registry/GetTarget", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) InformProcessShutdown(ctx context.Context, in *ProcessShutdownRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/registry.Registry/InformProcessShutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) V2CreateService(ctx context.Context, in *CreateServiceRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/registry.Registry/V2CreateService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) V2RegisterService(ctx context.Context, in *RegisterServiceRequest, opts ...grpc.CallOption) (*RegisterServiceResponse, error) {
	out := new(RegisterServiceResponse)
	err := grpc.Invoke(ctx, "/registry.Registry/V2RegisterService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) V2HeartBeat(ctx context.Context, in *HeartBeatRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/registry.Registry/V2HeartBeat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) V2DeregisterService(ctx context.Context, in *DeregisterServiceRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/registry.Registry/V2DeregisterService", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) V2GetTarget(ctx context.Context, in *V2GetTargetRequest, opts ...grpc.CallOption) (*V2GetTargetResponse, error) {
	out := new(V2GetTargetResponse)
	err := grpc.Invoke(ctx, "/registry.Registry/V2GetTarget", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) ListRegistrations(ctx context.Context, in *V2ListRequest, opts ...grpc.CallOption) (*RegistrationList, error) {
	out := new(RegistrationList)
	err := grpc.Invoke(ctx, "/registry.Registry/ListRegistrations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) RequestForTarget(ctx context.Context, in *UpstreamTargetRequest, opts ...grpc.CallOption) (*DownstreamTargetResponse, error) {
	out := new(DownstreamTargetResponse)
	err := grpc.Invoke(ctx, "/registry.Registry/RequestForTarget", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registryClient) GetMissedLookups(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*MissedLookupList, error) {
	out := new(MissedLookupList)
	err := grpc.Invoke(ctx, "/registry.Registry/GetMissedLookups", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Registry service

type RegistryServer interface {
	// DEPRECATED get all instances of a service
	GetTarget(context.Context, *GetTargetRequest) (*ListResponse, error)
	// this is called, by the autodeployer if it detects a shutdown process
	// essentially the ports and ip will be deregistered
	InformProcessShutdown(context.Context, *ProcessShutdownRequest) (*EmptyResponse, error)
	// autodeployer will a service before handing over control to userspace (using processid)
	V2CreateService(context.Context, *CreateServiceRequest) (*common.Void, error)
	// new style registration
	V2RegisterService(context.Context, *RegisterServiceRequest) (*RegisterServiceResponse, error)
	// new style 'refresh' (keep-alive)
	V2HeartBeat(context.Context, *HeartBeatRequest) (*common.Void, error)
	// new style 'deregister' service. This is based on processID. all services/ports for
	// the given processid will be deregistered.
	V2DeregisterService(context.Context, *DeregisterServiceRequest) (*common.Void, error)
	// new style queries. this will give us specific services, e.g. only the latest instance
	// or "the right instance" - whatever that might turn out to be. It won't for example
	// give instances that are scheduled for shutdown or so.
	V2GetTarget(context.Context, *V2GetTargetRequest) (*V2GetTargetResponse, error)
	// admin stuff to look at what is registered and to create graphs and whatnot for it
	// this gives all registrations
	ListRegistrations(context.Context, *V2ListRequest) (*RegistrationList, error)
	// registry-to-registry target resolutions.
	// a registry calls this rpc on a remote registry with the request to resolve a target
	RequestForTarget(context.Context, *UpstreamTargetRequest) (*DownstreamTargetResponse, error)
	// get me list of missed (local) target (those pulled from upstream)
	GetMissedLookups(context.Context, *common.Void) (*MissedLookupList, error)
}

func RegisterRegistryServer(s *grpc.Server, srv RegistryServer) {
	s.RegisterService(&_Registry_serviceDesc, srv)
}

func _Registry_GetTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).GetTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/GetTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).GetTarget(ctx, req.(*GetTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_InformProcessShutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessShutdownRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).InformProcessShutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/InformProcessShutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).InformProcessShutdown(ctx, req.(*ProcessShutdownRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_V2CreateService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).V2CreateService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/V2CreateService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).V2CreateService(ctx, req.(*CreateServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_V2RegisterService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).V2RegisterService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/V2RegisterService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).V2RegisterService(ctx, req.(*RegisterServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_V2HeartBeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartBeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).V2HeartBeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/V2HeartBeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).V2HeartBeat(ctx, req.(*HeartBeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_V2DeregisterService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeregisterServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).V2DeregisterService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/V2DeregisterService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).V2DeregisterService(ctx, req.(*DeregisterServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_V2GetTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(V2GetTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).V2GetTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/V2GetTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).V2GetTarget(ctx, req.(*V2GetTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_ListRegistrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(V2ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).ListRegistrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/ListRegistrations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).ListRegistrations(ctx, req.(*V2ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_RequestForTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpstreamTargetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).RequestForTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/RequestForTarget",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).RequestForTarget(ctx, req.(*UpstreamTargetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Registry_GetMissedLookups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistryServer).GetMissedLookups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/registry.Registry/GetMissedLookups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistryServer).GetMissedLookups(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _Registry_serviceDesc = grpc.ServiceDesc{
	ServiceName: "registry.Registry",
	HandlerType: (*RegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTarget",
			Handler:    _Registry_GetTarget_Handler,
		},
		{
			MethodName: "InformProcessShutdown",
			Handler:    _Registry_InformProcessShutdown_Handler,
		},
		{
			MethodName: "V2CreateService",
			Handler:    _Registry_V2CreateService_Handler,
		},
		{
			MethodName: "V2RegisterService",
			Handler:    _Registry_V2RegisterService_Handler,
		},
		{
			MethodName: "V2HeartBeat",
			Handler:    _Registry_V2HeartBeat_Handler,
		},
		{
			MethodName: "V2DeregisterService",
			Handler:    _Registry_V2DeregisterService_Handler,
		},
		{
			MethodName: "V2GetTarget",
			Handler:    _Registry_V2GetTarget_Handler,
		},
		{
			MethodName: "ListRegistrations",
			Handler:    _Registry_ListRegistrations_Handler,
		},
		{
			MethodName: "RequestForTarget",
			Handler:    _Registry_RequestForTarget_Handler,
		},
		{
			MethodName: "GetMissedLookups",
			Handler:    _Registry_GetMissedLookups_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protos/golang.conradwood.net/apis/registry/registry.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/registry/registry.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1518 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x58, 0x4f, 0x73, 0x1b, 0x35,
	0x14, 0x67, 0x6d, 0x27, 0x8e, 0x9f, 0xe3, 0xc4, 0x11, 0x6d, 0xba, 0xf5, 0x84, 0x12, 0x04, 0xc3,
	0x64, 0xca, 0xe0, 0x14, 0x77, 0xe8, 0x3f, 0x32, 0x53, 0x92, 0x3a, 0x4d, 0xcc, 0xa4, 0x8c, 0x47,
	0x49, 0x03, 0x1c, 0xb7, 0xb6, 0xea, 0x2c, 0xb5, 0x57, 0x8b, 0x24, 0x37, 0xe3, 0x03, 0x27, 0x2e,
	0xdc, 0xb9, 0x33, 0xdc, 0xb8, 0x73, 0xe4, 0x63, 0xf0, 0x15, 0xe0, 0xc2, 0xb7, 0x60, 0xa4, 0xd5,
	0xee, 0x6a, 0xd7, 0xae, 0xd3, 0x84, 0x4b, 0x22, 0x3d, 0xbd, 0x27, 0xbd, 0xbf, 0xbf, 0xf7, 0xbc,
	0xf0, 0x30, 0xe4, 0x4c, 0x32, 0xb1, 0x3d, 0x60, 0x43, 0x2f, 0x18, 0x34, 0x7b, 0x2c, 0xe0, 0x5e,
	0xff, 0x9c, 0xb1, 0x7e, 0x33, 0xa0, 0x72, 0xdb, 0x0b, 0x7d, 0xb1, 0xcd, 0xe9, 0xc0, 0x17, 0x92,
	0x4f, 0x92, 0x45, 0x53, 0xcb, 0xa0, 0xa5, 0x78, 0xdf, 0x68, 0xce, 0x91, 0xee, 0xb1, 0xd1, 0x88,
	0x05, 0xe6, 0x5f, 0x24, 0xd9, 0xb8, 0x3d, 0x87, 0xdf, 0x1b, 0xcb, 0x33, 0xfd, 0xc7, 0xf0, 0x3e,
	0x9a, 0xcf, 0xcb, 0xfa, 0x34, 0x1c, 0xb2, 0x09, 0xe5, 0x99, 0x4d, 0x24, 0x8b, 0xff, 0x76, 0xa0,
	0x4a, 0xd8, 0x58, 0xfa, 0xc1, 0xa0, 0x13, 0xbc, 0x64, 0x68, 0x0b, 0x2a, 0x64, 0x1c, 0x04, 0x7e,
	0x30, 0xd8, 0x15, 0xae, 0xb3, 0xe9, 0x6c, 0x55, 0x5b, 0xd0, 0xd4, 0x6f, 0x3d, 0x17, 0x94, 0x93,
	0xf4, 0x10, 0x6d, 0x40, 0xe5, 0xc0, 0x93, 0xf4, 0xdc, 0x9b, 0x74, 0xda, 0x6e, 0x61, 0xd3, 0xd9,
	0xaa, 0x90, 0x94, 0x80, 0x6e, 0x01, 0xec, 0x07, 0xfd, 0x90, 0xf9, 0x81, 0xec, 0xb4, 0xdd, 0xa2,
	0x3e, 0xb6, 0x28, 0xe8, 0x2e, 0x94, 0x4e, 0xbc, 0x81, 0x70, 0x4b, 0x9b, 0xc5, 0xad, 0x6a, 0xeb,
	0xfd, 0x66, 0xe2, 0x38, 0x4b, 0x99, 0xa6, 0xe2, 0xd8, 0x0f, 0x24, 0x9f, 0x10, 0xcd, 0xdc, 0xb8,
	0x0f, 0x95, 0x84, 0x84, 0xea, 0x50, 0x7c, 0x45, 0x27, 0x5a, 0xc7, 0x0a, 0x51, 0x4b, 0x74, 0x0d,
	0x16, 0x5e, 0x7b, 0xc3, 0x31, 0x35, 0xda, 0x44, 0x9b, 0x47, 0x85, 0x07, 0x0e, 0xde, 0x01, 0x74,
	0x4c, 0xf9, 0x6b, 0xbf, 0x47, 0xdb, 0x54, 0xf4, 0xb8, 0x1f, 0x4a, 0x9f, 0x05, 0x08, 0x41, 0xe9,
	0x6b, 0x6f, 0x44, 0xcd, 0x15, 0x7a, 0xad, 0x68, 0x5d, 0x4f, 0x9e, 0x99, 0x2b, 0xf4, 0x1a, 0xff,
	0xe9, 0xc0, 0x8a, 0x11, 0xdf, 0xed, 0xf7, 0x39, 0x15, 0x42, 0xb1, 0x1d, 0x32, 0x21, 0x63, 0x51,
	0xb5, 0xd6, 0xa2, 0x8c, 0x4b, 0x2d, 0xba, 0x40, 0xf4, 0x1a, 0x7d, 0x02, 0xe5, 0xdd, 0xd0, 0x3f,
	0x99, 0x84, 0xd4, 0x2d, 0x6e, 0x16, 0xb7, 0x56, 0x5a, 0x6b, 0xa9, 0xa5, 0xbb, 0xa1, 0x2f, 0x27,
	0x21, 0x25, 0x31, 0x07, 0x6a, 0xc0, 0xd2, 0x53, 0x7f, 0x28, 0x29, 0xa7, 0x7d, 0xb7, 0xb4, 0xe9,
	0x6c, 0x2d, 0x91, 0x64, 0x8f, 0xee, 0x67, 0xc2, 0xe4, 0x2e, 0xe8, 0xc8, 0x5c, 0x9f, 0xe9, 0x36,
	0x62, 0x73, 0xe2, 0x1f, 0x61, 0xd5, 0xe8, 0x7e, 0xc4, 0x7a, 0x9e, 0xb6, 0xfb, 0x1e, 0x94, 0x0d,
	0xc9, 0x44, 0x78, 0x23, 0xbd, 0x67, 0xda, 0x4d, 0x24, 0x66, 0x46, 0x2d, 0x28, 0x1b, 0xfb, 0xdd,
	0x82, 0x0e, 0x9b, 0x3b, 0x25, 0x67, 0xce, 0x49, 0xcc, 0x88, 0xdb, 0x00, 0x07, 0x54, 0x12, 0xfa,
	0xc3, 0x98, 0x0a, 0x79, 0xd5, 0x97, 0xf1, 0x1f, 0x0e, 0x54, 0xf5, 0x35, 0x22, 0x64, 0x81, 0xa0,
	0x57, 0xb6, 0xe0, 0x73, 0x58, 0x8a, 0xbd, 0xa0, 0xc3, 0x54, 0x6d, 0xdd, 0x9c, 0x12, 0x8c, 0x19,
	0x48, 0xc2, 0xaa, 0x52, 0xdd, 0x1c, 0x26, 0xb9, 0x9c, 0x12, 0xd0, 0x3a, 0x2c, 0x7e, 0xc7, 0xc6,
	0xbc, 0xd3, 0xd5, 0x41, 0xab, 0x10, 0xb3, 0xc3, 0x77, 0x61, 0xf5, 0xf8, 0x6c, 0x2c, 0xfb, 0xec,
	0x3c, 0x88, 0xed, 0xdf, 0x84, 0xaa, 0x91, 0xb3, 0x12, 0xcf, 0x26, 0xe1, 0xc7, 0xb0, 0x7c, 0xe4,
	0x8b, 0xd4, 0xd2, 0xed, 0xd4, 0xd2, 0xa2, 0xf6, 0xb9, 0x15, 0x73, 0xcb, 0x23, 0xa9, 0xab, 0x56,
	0xa1, 0xb6, 0x3f, 0x0a, 0xe5, 0x24, 0x3e, 0xc1, 0x03, 0xa8, 0x46, 0x37, 0x46, 0x2a, 0xcc, 0x4a,
	0x7a, 0x0c, 0xcb, 0xc7, 0x67, 0xec, 0x3c, 0x49, 0xbe, 0x82, 0x4e, 0xbe, 0x0c, 0x4d, 0xa9, 0xae,
	0x78, 0x9f, 0x79, 0xb2, 0x77, 0x46, 0x85, 0x56, 0xa6, 0x42, 0x6c, 0x12, 0xfe, 0x0c, 0xd6, 0xda,
	0x34, 0x52, 0x8e, 0xf2, 0xf8, 0xb9, 0x8c, 0xeb, 0x9c, 0x9c, 0xeb, 0xf0, 0x6b, 0x70, 0x0f, 0xa8,
	0x7c, 0x1e, 0x0a, 0xc9, 0xa9, 0x37, 0x3a, 0xf1, 0xf8, 0x20, 0xcd, 0x95, 0x2f, 0xa1, 0x96, 0x21,
	0x98, 0x80, 0x35, 0x32, 0xf6, 0x67, 0x38, 0x48, 0x56, 0x00, 0xb9, 0x50, 0x7e, 0xe2, 0x0d, 0x87,
	0x94, 0x47, 0xea, 0x96, 0x48, 0xbc, 0xc5, 0x03, 0xa8, 0xe7, 0x85, 0x93, 0xca, 0x77, 0xd2, 0xca,
	0x4f, 0x9c, 0x55, 0xb0, 0x9c, 0x95, 0x29, 0x69, 0x67, 0x7e, 0x49, 0xe3, 0x1d, 0x58, 0xef, 0x72,
	0xd6, 0xa3, 0x42, 0xe4, 0x53, 0x61, 0x05, 0x0a, 0x9d, 0xae, 0x79, 0xac, 0xd0, 0xe9, 0x5a, 0xe8,
	0x51, 0x8c, 0xd1, 0x03, 0x7f, 0x01, 0x6b, 0x87, 0x7e, 0x9f, 0x3e, 0x0f, 0xfb, 0x9e, 0xa4, 0x6f,
	0x12, 0x5c, 0x87, 0xc5, 0xfd, 0xc0, 0x7b, 0x31, 0xa4, 0x26, 0x6c, 0x66, 0x87, 0x43, 0x40, 0x4a,
	0xd8, 0x38, 0x3b, 0x96, 0xb6, 0x6a, 0x38, 0xaa, 0x9c, 0x8b, 0x6b, 0x18, 0x7d, 0x0c, 0x2b, 0x27,
	0xfe, 0x88, 0xb2, 0xb1, 0x3c, 0xa6, 0x3d, 0x16, 0xf4, 0x85, 0x81, 0xb8, 0x1c, 0x15, 0xf7, 0x60,
	0x75, 0x6f, 0xd2, 0xe9, 0x2a, 0xd5, 0xad, 0x10, 0xd8, 0xcf, 0x55, 0xd2, 0x4b, 0x6d, 0xb4, 0xac,
	0x19, 0xb4, 0xcc, 0xe7, 0x61, 0x71, 0x3a, 0x0f, 0xf1, 0x2f, 0x0e, 0xd4, 0xd3, 0x57, 0xfe, 0x27,
	0x1e, 0x58, 0xb1, 0x2c, 0x5c, 0x0a, 0x9e, 0x8b, 0x59, 0x78, 0xc6, 0xbf, 0x3a, 0x70, 0xed, 0x09,
	0xa7, 0x9e, 0xcc, 0xfb, 0x7b, 0x03, 0x2a, 0x26, 0x01, 0xd2, 0xfc, 0x4f, 0x08, 0xe8, 0x01, 0x40,
	0x5b, 0xf7, 0x63, 0x0d, 0xea, 0x05, 0x13, 0x90, 0x4c, 0x9b, 0x4e, 0xcf, 0x89, 0xc5, 0xab, 0xef,
	0xf5, 0xb8, 0xf4, 0x35, 0x94, 0x19, 0x48, 0x4a, 0x08, 0xaa, 0x37, 0x76, 0xfd, 0xa8, 0x89, 0x94,
	0x88, 0x5a, 0xe2, 0x7f, 0x1c, 0x58, 0x27, 0xa6, 0x36, 0x2f, 0xa5, 0xe2, 0xac, 0x38, 0x5d, 0xaa,
	0xab, 0xe5, 0x30, 0xaf, 0x34, 0x85, 0x79, 0x57, 0xee, 0x6d, 0xb1, 0x99, 0x8b, 0xa9, 0x99, 0x37,
	0xe1, 0xc6, 0x94, 0x95, 0x06, 0x07, 0xef, 0x40, 0xfd, 0x90, 0x7a, 0x5c, 0xee, 0x51, 0x4f, 0xbe,
	0x95, 0xe9, 0xf8, 0x01, 0xb8, 0x29, 0xa0, 0x5d, 0xc6, 0x69, 0xf8, 0x2f, 0x07, 0x16, 0x23, 0x74,
	0xb9, 0x18, 0xf2, 0x4d, 0x41, 0x17, 0xa6, 0x90, 0xa0, 0x38, 0xdb, 0xe3, 0xa5, 0x0b, 0x3d, 0x7e,
	0x65, 0x7f, 0x66, 0x92, 0x6a, 0x31, 0x97, 0x54, 0xf8, 0x77, 0x07, 0xd0, 0x69, 0x6b, 0x0a, 0x37,
	0x2d, 0xd5, 0x9c, 0x8b, 0xf0, 0x30, 0xef, 0x8d, 0x42, 0xd4, 0x45, 0x6c, 0x6f, 0xcc, 0x4f, 0xec,
	0x8f, 0xa0, 0xb6, 0x3b, 0x1c, 0x26, 0x7b, 0x61, 0xe6, 0xa4, 0x2c, 0x11, 0xef, 0xc2, 0xbb, 0x19,
	0x45, 0x0d, 0x4a, 0xdc, 0x86, 0x72, 0x44, 0x51, 0x60, 0xa4, 0x7a, 0x69, 0x3d, 0xd5, 0xd4, 0xb0,
	0xc6, 0x0c, 0xf8, 0xb7, 0x02, 0x2c, 0x47, 0x99, 0xc4, 0xa3, 0x19, 0x60, 0x2b, 0x8e, 0xa8, 0x41,
	0x98, 0x69, 0xd9, 0x38, 0xe2, 0xb7, 0x00, 0xa2, 0x95, 0x05, 0xca, 0x16, 0x25, 0x9b, 0x3a, 0xc5,
	0xf9, 0x90, 0x50, 0xba, 0x04, 0x24, 0x98, 0x6a, 0x58, 0x48, 0xaa, 0x41, 0x79, 0xeb, 0xc8, 0x53,
	0xad, 0xff, 0x25, 0xa7, 0xe2, 0x8c, 0x46, 0x95, 0x52, 0x23, 0x59, 0x62, 0xd6, 0xe3, 0xe5, 0xbc,
	0xc7, 0x5d, 0x28, 0x9b, 0x99, 0xdf, 0x5d, 0xd2, 0xa6, 0xc4, 0x5b, 0xdc, 0x85, 0xba, 0xed, 0x21,
	0x35, 0x64, 0xa0, 0x1d, 0xa8, 0xd9, 0xb4, 0xd8, 0xd1, 0xeb, 0x56, 0xf2, 0x59, 0xc7, 0x24, 0xcb,
	0x8c, 0x3f, 0x85, 0xda, 0x69, 0xcb, 0x1e, 0x56, 0x36, 0xa0, 0x92, 0x4c, 0x18, 0x71, 0x95, 0x25,
	0x04, 0x7c, 0x0e, 0x6e, 0x9b, 0x9d, 0x07, 0xd9, 0xe1, 0xc1, 0xc4, 0xfa, 0x21, 0x2c, 0xc5, 0x6b,
	0x13, 0xb0, 0xf7, 0x52, 0x1d, 0x66, 0x24, 0x07, 0x49, 0xd8, 0x55, 0x8e, 0x1a, 0xb5, 0x26, 0x9d,
	0xb6, 0x88, 0x73, 0xd4, 0x22, 0xe1, 0x9f, 0x1c, 0xb8, 0x3e, 0x7b, 0x68, 0xb9, 0x07, 0xe5, 0x78,
	0x5c, 0x99, 0x6a, 0x44, 0xd3, 0xb5, 0x43, 0xca, 0xd6, 0x60, 0x38, 0xff, 0x4d, 0x15, 0xdd, 0x93,
	0x93, 0x23, 0x03, 0x0a, 0x6a, 0x89, 0x39, 0x2c, 0x3f, 0xf3, 0x85, 0xa0, 0xfd, 0x23, 0xc6, 0x5e,
	0x8d, 0xc3, 0xb7, 0x40, 0x1a, 0x04, 0x25, 0x15, 0xfa, 0x18, 0xcb, 0xd5, 0x5a, 0x8d, 0x0f, 0xd1,
	0x2d, 0xe6, 0x6a, 0xb3, 0x53, 0x3f, 0xa6, 0x9e, 0xb2, 0x71, 0x10, 0x35, 0x91, 0x1a, 0x89, 0x36,
	0xb8, 0x0d, 0x75, 0xfb, 0x4d, 0x1d, 0xf3, 0x3b, 0x50, 0x8e, 0x76, 0x33, 0xa2, 0x6d, 0x33, 0x93,
	0x98, 0xed, 0xf6, 0x8e, 0x86, 0x0c, 0x85, 0x0c, 0x08, 0x60, 0x51, 0x48, 0x4f, 0x8e, 0x45, 0xfd,
	0x1d, 0xb4, 0x04, 0xa5, 0x01, 0x0f, 0x7b, 0x75, 0x47, 0xad, 0xbe, 0x17, 0x2c, 0xa8, 0x17, 0xd4,
	0xea, 0x4c, 0x8e, 0x86, 0xf5, 0x22, 0x2a, 0x43, 0x51, 0xf6, 0xc2, 0x7a, 0xa9, 0xf5, 0xef, 0x82,
	0x8a, 0x6d, 0xf4, 0x00, 0x7a, 0x0c, 0x95, 0xc4, 0xab, 0x68, 0xce, 0x6c, 0xd8, 0xb0, 0x94, 0xca,
	0x0c, 0xd8, 0x04, 0xae, 0xab, 0xea, 0xe1, 0xa3, 0xdc, 0x9c, 0x86, 0x36, 0x53, 0x81, 0xd9, 0x23,
	0x5c, 0xe3, 0x46, 0xca, 0x91, 0x19, 0xb9, 0xd1, 0x63, 0x58, 0x3d, 0x6d, 0x65, 0xc6, 0x01, 0x74,
	0x2b, 0xe5, 0x9d, 0x35, 0x27, 0x34, 0x96, 0x9b, 0xe6, 0xe7, 0xff, 0x29, 0xf3, 0xfb, 0xe8, 0x5b,
	0x58, 0x3b, 0x6d, 0xe5, 0x1a, 0x99, 0xad, 0xd0, 0xec, 0x4e, 0xde, 0xf8, 0x60, 0x0e, 0x87, 0x51,
	0xed, 0x3e, 0x54, 0x4f, 0x5b, 0x49, 0x1f, 0xb4, 0x3d, 0x96, 0x6f, 0x8e, 0x39, 0x95, 0x0e, 0x14,
	0xa6, 0x4e, 0xb5, 0x43, 0x84, 0xd3, 0x0b, 0xde, 0xd4, 0x2b, 0x73, 0x17, 0x7d, 0xa5, 0x34, 0x48,
	0x63, 0x36, 0xb7, 0x40, 0x1a, 0xf3, 0x8b, 0x16, 0x1d, 0xc2, 0x5a, 0x14, 0x4c, 0x0b, 0x45, 0xd0,
	0x0d, 0x5b, 0xc6, 0x42, 0x93, 0x46, 0x63, 0x36, 0x0a, 0xe9, 0x24, 0xfe, 0x46, 0x81, 0x99, 0x66,
	0x7b, 0xca, 0xb8, 0x51, 0xcd, 0xfa, 0x2a, 0x31, 0xb3, 0xda, 0x1b, 0xb6, 0xf1, 0x6f, 0x02, 0xa2,
	0x1d, 0xfd, 0x53, 0xc3, 0xae, 0x03, 0x81, 0x32, 0x0e, 0xb1, 0xd5, 0xca, 0xd7, 0xd6, 0xde, 0x43,
	0xf8, 0x30, 0xa0, 0xd2, 0xfe, 0xb2, 0x63, 0xbe, 0xf5, 0x78, 0xa1, 0x2f, 0x12, 0xb9, 0xbd, 0x18,
	0x47, 0x27, 0x5d, 0xce, 0x24, 0xeb, 0x3a, 0x3f, 0x3b, 0xce, 0x8b, 0x45, 0xfd, 0x81, 0xe7, 0xee,
	0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x4f, 0xd6, 0xa0, 0x7d, 0xbf, 0x12, 0x00, 0x00,
}
